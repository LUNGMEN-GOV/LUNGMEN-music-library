<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>贪吃蛇游戏</title>
<style>
html, body {
margin: 0;
padding: 0;
overflow: hidden;
background: #111;
font-family: "华文仿宋", "STFangsong", serif;
}
canvas {
display: block;
background: #222;
}
/* 右上角信息与开关 */
#scoreBoard {
position: absolute;
top: 10px;
left: 10px;
color: white;
font-size: 20px;
z-index: 10;
}
#friendlyToggle {
position: absolute;
top: 10px;
right: 10px;
z-index: 10;
color: white;
font-size: 20px;
}
#friendlyToggle label {
cursor: pointer;
}
</style>
</head>
<body>
<div id="scoreBoard">得分: 0 最高分: 0</div>
<div id="friendlyToggle">
<label>
<input type="checkbox" id="ffSwitch">
友伤开关
</label>
</div>
<canvas id="gameCanvas"></canvas>
<script>
/***************** 全局设置 *****************/
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
window.addEventListener('resize', () => {
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
});

// 地图尺寸：3000×3000
const MAP_WIDTH = 3000, MAP_HEIGHT = 3000;

// 食物设置
const FOOD_NORMAL_RADIUS = 6; // 普通食物半径
const SNAKE_BODY_RADIUS = 10; // 蛇身体球半径
// 蛇头原先为 SNAKE_BODY_RADIUS * 1.3，现在缩小为 0.95 倍
const SNAKE_HEAD_RADIUS = SNAKE_BODY_RADIUS * 1.3 * 0.95;
// 超级食物：持续30秒，大小为蛇身体球的2.3倍
const SUPER_FOOD_DURATION = 30000; // 30秒倒计时
const SUPER_FOOD_RADIUS = SNAKE_BODY_RADIUS * 2.3;
// 超级食物在消失前10秒显示倒计时数字

const FOOD_REFRESH_INTERVAL = 15000; // 每15秒刷新一次食物
const GRID_SIZE = 200; // 小区块尺寸

// 蛇的设置
const SNAKE_SPACING = SNAKE_BODY_RADIUS * 2; // 蛇球之间距离
const PLAYER_SPEED = 3 * 0.9; // 玩家蛇速度
const COMP_SPEED = 2.7 * 0.9; // 电脑蛇速度

// 炸弹球设置（红色炸弹球）
// 大小为超级食物的1.3倍，速度为玩家蛇速度的1.8倍
const BOMB_RADIUS = SUPER_FOOD_RADIUS * 1.3;
const BOMB_SPEED = PLAYER_SPEED * 1.8;

/***************** 音效设置 *****************/
const soundElimination = new Audio('elimination.mp3'); // 电脑蛇被淘汰音效
soundElimination.preload = "auto";
soundElimination.load();
soundElimination.play();
const soundPlayerEliminated = new Audio('player_eliminated.mp3'); // 玩家蛇被淘汰音效
soundPlayerEliminated.preload = "auto";
soundPlayerEliminated.load();
soundPlayerEliminated.play();
const soundSuperFood = new Audio('superfood.mp3'); // 吃超级食物音效
soundSuperFood.preload = "auto";
soundSuperFood.load();
soundSuperFood.play();
const soundBoundaryHit = new Audio('boundary.mp3'); // 触碰边界音效
soundBoundaryHit.preload = "auto";
soundBoundaryHit.load();
soundBoundaryHit.play();
const soundBombHit = new Audio('explode.mp3'); // 炸弹球碰撞音效
soundBombHit.preload = "auto";
soundBombHit.load();
soundBombHit.play();

// 播放音效函数
function playSound(audioObj) {
if(audioObj && typeof audioObj.play === 'function'){
audioObj.currentTime = 0;
audioObj.play();
}
}

/***************** 友伤开关持久化 *****************/
let friendlyFireEnabled = localStorage.getItem('friendlyFireEnabled') === 'false';
const ffSwitch = document.getElementById('ffSwitch');
ffSwitch.checked = friendlyFireEnabled;
ffSwitch.addEventListener('change', (e) => {
friendlyFireEnabled = e.target.checked;
localStorage.setItem('friendlyFireEnabled', friendlyFireEnabled);
});

/***************** 工具函数 *****************/
function random(min, max) { return Math.random() * (max - min) + min; }
function randomInt(min, max) { return Math.floor(random(min, max)); }
function randomColorNoRed() {
let hue;
do {
hue = randomInt(0, 360);
} while ((hue >= 340 || hue <= 20));
return 'hsl(' + hue + ', 70%, 50%)';
}
function randomColor() { return 'hsl(' + randomInt(0, 360) + ', 70%, 50%)'; }

/***************** 全局变量 *****************/
let foods = [];
let snakes = [];
let bombs = [];
// 控制指针，统一命名为 controlPos
let controlPos = { x: canvas.width/2, y: canvas.height/2 };

/***************** 食物类 *****************/
class Food {
constructor(x, y, type = 'normal') {
this.x = x;
this.y = y;
this.type = type; // 'normal'、'super'、'corpse'
if(this.type === 'super'){
this.color = randomColorNoRed();
this.spawnTime = Date.now();
} else {
this.color = randomColor();
}
this.opacity = 1;
}
draw() {
ctx.save();
ctx.globalAlpha = this.opacity;
ctx.fillStyle = this.color;
ctx.beginPath();
let radius;
if (this.type === 'normal') {
radius = FOOD_NORMAL_RADIUS;
} else if (this.type === 'super') {
radius = SUPER_FOOD_RADIUS;
} else if (this.type === 'corpse') {
radius = FOOD_NORMAL_RADIUS * 1.3;
}
ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
ctx.fill();
ctx.restore();
if(this.type === 'super'){
let elapsed = Date.now() - this.spawnTime;
let remaining = SUPER_FOOD_DURATION - elapsed;
if(remaining <= 10000 && remaining > 0){
let seconds = Math.ceil(remaining/1000);
ctx.save();
ctx.fillStyle = "white";
ctx.font = "bold 20px sans-serif";
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillText(seconds, this.x, this.y);
ctx.restore();
}
}
}
update() {
if(this.type === 'super'){
let elapsed = Date.now() - this.spawnTime;
if(elapsed > SUPER_FOOD_DURATION){
this.opacity = 0;
}
}
}
}

/***************** 蛇类 *****************/
class Snake {
constructor(x, y, color, isPlayer = false, initLength = 3) {
this.segments = [];
for (let i = 0; i < initLength; i++) {
this.segments.push({ x: x - i * SNAKE_SPACING, y: y });
}
this.color = isPlayer ? '#0f0' : randomColorNoRed();
this.isPlayer = isPlayer;
this.pendingGrowth = 0;
this.normalFoodEaten = 0;
this.alive = true;
this.direction = { x: 1, y: 0 };
this.speed = isPlayer ? PLAYER_SPEED : COMP_SPEED;
this.disappearOpacity = 1;
this.dying = false;
}

get head() { return this.segments[0]; }

update() {
if(!this.alive){
if(this.dying){
this.disappearOpacity -= 0.04;
if(this.disappearOpacity <= 0){
spawnCorpseFoods(this);
this.dying = false;
}
}
return;
}

// 玩家蛇：根据控制指针（controlPos）调整方向
if (this.isPlayer) {
let camX = this.head.x - canvas.width / 2;
let camY = this.head.y - canvas.height / 2;
let worldControl = { x: controlPos.x + camX, y: controlPos.y + camY };
let dx = worldControl.x - this.head.x;
let dy = worldControl.y - this.head.y;
let mag = Math.hypot(dx, dy);
if(mag !== 0){
this.direction.x = dx / mag;
this.direction.y = dy / mag;
}
}

let newHead = {
x: this.head.x + this.direction.x * this.speed,
y: this.head.y + this.direction.y * this.speed
};
if(newHead.x < 0 || newHead.x > MAP_WIDTH || newHead.y < 0 || newHead.y > MAP_HEIGHT){
this.eliminate("boundary");
return;
}
this.segments[0] = newHead;

for(let i = 1; i < this.segments.length; i++){
let prev = this.segments[i-1];
let curr = this.segments[i];
let dx = prev.x - curr.x;
let dy = prev.y - curr.y;
let dist = Math.hypot(dx, dy);
if(dist > 0){
let t = (dist - SNAKE_SPACING) / dist;
if(t > 0){
curr.x += dx * t;
curr.y += dy * t;
}
}
}
if(this.pendingGrowth > 0){
let tail = this.segments[this.segments.length - 1];
this.segments.push({ x: tail.x, y: tail.y });
this.pendingGrowth--;
}

if(friendlyFireEnabled && this.segments.length >= 4){
for(let i = 2; i < this.segments.length; i++){
let seg = this.segments[i];
let d = Math.hypot(this.head.x - seg.x, this.head.y - seg.y);
if(d < SNAKE_BODY_RADIUS * 0.9){
this.eliminate();
break;
}
}
}
}

draw() {
for(let i = 0; i < this.segments.length; i++){
ctx.save();
if(!this.alive){
ctx.globalAlpha = this.disappearOpacity;
}
ctx.fillStyle = this.color;
ctx.beginPath();
let radius = (i===0) ? SNAKE_HEAD_RADIUS : SNAKE_BODY_RADIUS;
ctx.arc(this.segments[i].x, this.segments[i].y, radius, 0, Math.PI*2);
ctx.fill();
ctx.restore();
}
}

eliminate(cause) {
if(this.alive){
this.alive = false;
this.dying = true;
if(this.isPlayer){
    if(cause == "bomb"){
        playSound(soundBombHit);
        playSound(soundPlayerEliminated);
    } else if(cause == "boundary"){
        playSound(soundBoundaryHit);
    } else {
        playSound(soundPlayerEliminated);
    }
} else {
playSound(soundElimination);
}
}
if(this.isPlayer) gameOver();
}
}

/***************** 炸弹球类 *****************/
class Bomb {
constructor(x, y, dx, dy) {
this.x = x;
this.y = y;
this.direction = { x: dx, y: dy };
this.speed = BOMB_SPEED;
this.radius = BOMB_RADIUS;
this.color = 'red';
this.alive = true;
this.dying = false;
this.disappearOpacity = 1;
}
update() {
if(!this.alive) return;
if(this.dying){
this.disappearOpacity -= 0.04;
if(this.disappearOpacity <= 0){
this.alive = false;
}
return;
}
this.x += this.direction.x * this.speed;
this.y += this.direction.y * this.speed;
if(this.x - this.radius < 0 || this.x + this.radius > MAP_WIDTH){
this.direction.x *= -1;
}
if(this.y - this.radius < 0 || this.y + this.radius > MAP_HEIGHT){
this.direction.y *= -1;
}
}
draw() {
if(!this.alive) return;
ctx.save();
ctx.globalAlpha = this.dying ? this.disappearOpacity : 1;
ctx.fillStyle = this.color;
ctx.beginPath();
ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
ctx.fill();
ctx.restore();
}
eliminate() {
if(!this.dying){
this.dying = true;
playSound(soundBombHit);
}
}
}

/***************** 初始生成 *****************/
let playerSnake = new Snake(MAP_WIDTH/2, MAP_HEIGHT/2, '#0f0', true);
snakes.push(playerSnake);

function spawnComputerSnake() {
let spawnX, spawnY;
do {
spawnX = random(0, MAP_WIDTH);
spawnY = random(0, MAP_HEIGHT);
} while(Math.hypot(spawnX - playerSnake.head.x, spawnY - playerSnake.head.y) < 300);
let initLength = Math.max(3, Math.floor(playerSnake.segments.length * 0.65));
let compSnake = new Snake(spawnX, spawnY, randomColorNoRed(), false, initLength);
snakes.push(compSnake);
}
for(let i = 0; i < 5; i++){
spawnComputerSnake();
}

for(let i = 0; i < 350; i++){
let fx = random(0, MAP_WIDTH);
let fy = random(0, MAP_HEIGHT);
let type = (Math.random() < 0.05) ? 'super' : 'normal';
foods.push(new Food(fx, fy, type));
}

function spawnBomb() {
let bx = random(BOMB_RADIUS, MAP_WIDTH - BOMB_RADIUS);
let by = random(BOMB_RADIUS, MAP_HEIGHT - BOMB_RADIUS);
let angle = random(0, Math.PI*2);
return new Bomb(bx, by, Math.cos(angle), Math.sin(angle));
}
while(bombs.length < 3){
bombs.push(spawnBomb());
}

/***************** 食物刷新与炸弹球补齐 *****************/
function refreshFoodByDensity() {
let cols = Math.ceil(MAP_WIDTH/GRID_SIZE);
let rows = Math.ceil(MAP_HEIGHT/GRID_SIZE);
let grid = Array(rows).fill(0).map(() => Array(cols).fill(0));
for(let f of foods){
let col = Math.floor(f.x/GRID_SIZE);
let row = Math.floor(f.y/GRID_SIZE);
if(row < rows && col < cols) grid[row][col]++;
}
const threshold = 3;
for(let r = 0; r < rows; r++){
for(let c = 0; c < cols; c++){
if(grid[r][c] < threshold){
let fx = random(c * GRID_SIZE, (c+1)*GRID_SIZE);
let fy = random(r * GRID_SIZE, (r+1)*GRID_SIZE);
let type = (Math.random() < 0.05) ? 'super' : 'normal';
foods.push(new Food(fx, fy, type));
}
}
}
let compCount = snakes.filter(s => !s.isPlayer && s.alive).length;
if(compCount < 3){
spawnComputerSnake();
}
bombs = bombs.filter(b => b.alive || b.dying);
while(bombs.length < 3){
bombs.push(spawnBomb());
}
}
setInterval(refreshFoodByDensity, FOOD_REFRESH_INTERVAL);

/***************** 控制方式绑定 *****************/
// 判断是否为移动端（检测 touch 事件支持）
if ('ontouchstart' in window) {
canvas.addEventListener('touchmove', function(e) {
e.preventDefault(); // 防止页面滚动
let touch = e.touches[0];
controlPos.x = touch.clientX;
controlPos.y = touch.clientY;
}, {passive:false});
} else {
canvas.addEventListener('mousemove', (e) => {
controlPos.x = e.clientX;
controlPos.y = e.clientY;
});
}

/***************** 电脑蛇 AI *****************/
function updateComputerSnakeAI(snake) {
if(!snake.alive) return;
// 1. 避开附近炸弹球（圆形碰撞判定）
for(let bomb of bombs){
if(!bomb.alive) continue;
let dBomb = Math.hypot(snake.head.x - bomb.x, snake.head.y - bomb.y);
if(dBomb < (SNAKE_HEAD_RADIUS + bomb.radius)){
let dx = snake.head.x - bomb.x;
let dy = snake.head.y - bomb.y;
let mag = Math.hypot(dx, dy);
if(mag !== 0){
snake.direction.x = dx / mag;
snake.direction.y = dy / mag;
return;
}
}
}
// 2. 主动攻击距离400以内的其他蛇
let attackTarget = null;
let attackDist = Infinity;
for(let other of snakes){
if(other === snake || !other.alive) continue;
let d = Math.hypot(snake.head.x - other.head.x, snake.head.y - other.head.y);
if(d < 400 && d < attackDist){
attackTarget = other.head;
attackDist = d;
}
}
if(attackTarget){
let dx = attackTarget.x - snake.head.x;
let dy = attackTarget.y - snake.head.y;
let mag = Math.hypot(dx, dy);
if(mag !== 0){
snake.direction.x = dx / mag;
snake.direction.y = dy / mag;
}
return;
}
// 3. 若有超级食物，则前往
let target = null;
let minDist = Infinity;
for(let f of foods){
if(f.type === 'super'){
let d = Math.hypot(snake.head.x - f.x, snake.head.y - f.y);
if(d < minDist){
minDist = d;
target = { x: f.x, y: f.y };
}
}
}
if(target){
let dx = target.x - snake.head.x;
let dy = target.y - snake.head.y;
let mag = Math.hypot(dx, dy);
if(mag !== 0){
snake.direction.x = dx / mag;
snake.direction.y = dy / mag;
}
return;
}
// 4. 默认追踪玩家蛇
let dx = playerSnake.head.x - snake.head.x;
let dy = playerSnake.head.y - snake.head.y;
let mag = Math.hypot(dx, dy);
if(mag !== 0){
snake.direction.x = dx / mag;
snake.direction.y = dy / mag;
}
}

/***************** 碰撞检测 *****************/
function checkFoodCollision(snake) {
for(let i = foods.length - 1; i >= 0; i--){
let f = foods[i];
let radiusFood;
if(f.type === 'normal'){
radiusFood = FOOD_NORMAL_RADIUS;
} else if(f.type === 'super'){
radiusFood = SUPER_FOOD_RADIUS;
} else if(f.type === 'corpse'){
radiusFood = FOOD_NORMAL_RADIUS * 1.3;
}
let d = Math.hypot(snake.head.x - f.x, snake.head.y - f.y);
if(d < (SNAKE_HEAD_RADIUS + radiusFood)){
if(f.type === 'normal'){
snake.normalFoodEaten++;
if(snake.normalFoodEaten % 10 === 0){
snake.pendingGrowth += 1;
}
} else if(f.type === 'super'){
snake.normalFoodEaten += 10;
snake.pendingGrowth += 1;
if(snake.isPlayer){
    playSound(soundSuperFood);
}
} else if(f.type === 'corpse'){
snake.normalFoodEaten++;
if(snake.normalFoodEaten % 10 === 0){
snake.pendingGrowth += 1;
}
}
foods.splice(i, 1);
}
}
}

function checkSnakeCollisions() {
for(let s of snakes){
if(!s.alive) continue;
// 检查炸弹球碰撞（采用圆形检测：蛇头半径+炸弹球半径）
for(let bomb of bombs){
if(!bomb.alive) continue;
let dBomb = Math.hypot(s.head.x - bomb.x, s.head.y - bomb.y);
if(dBomb < (SNAKE_HEAD_RADIUS + bomb.radius)){
s.eliminate("bomb");
bomb.eliminate();
}
}
// 检查与其它蛇的碰撞（非相邻部分）
for(let other of snakes){
if(!other.alive) continue;
if(s === other) continue;
for(let j = 0; j < other.segments.length; j++){
let seg = other.segments[j];
let d = Math.hypot(s.head.x - seg.x, s.head.y - seg.y);
if(d < (SNAKE_HEAD_RADIUS + SNAKE_BODY_RADIUS * 0.9)){
s.eliminate("computer");
break;
}
}
}
}
}

function spawnCorpseFoods(snake) {
let count = snake.segments.length;
let center = snake.segments[snake.segments.length - 1];
for(let i = 0; i < count; i++){
let fx = center.x + random(-30, 30);
let fy = center.y + random(-30, 30);
foods.push(new Food(fx, fy, 'corpse'));
}
snakes = snakes.filter(s => s !== snake);
}

/***************** 主循环 *****************/
function gameLoop() {
ctx.clearRect(0, 0, canvas.width, canvas.height);

for(let bomb of bombs){
bomb.update();
}

for(let s of snakes){
if(s.alive){
if(!s.isPlayer){
updateComputerSnakeAI(s);
}
s.update();
checkFoodCollision(s);
} else {
s.update();
}
}
checkSnakeCollisions();

for(let i = foods.length - 1; i >= 0; i--){
let food = foods[i];
food.update();
if(food.type === 'super' && food.opacity <= 0){
foods.splice(i, 1);
}
}

let camX = playerSnake.head.x - canvas.width/2;
let camY = playerSnake.head.y - canvas.height/2;
ctx.save();
ctx.translate(-camX, -camY);

ctx.strokeStyle = 'red';
ctx.lineWidth = 3;
ctx.strokeRect(0, 0, MAP_WIDTH, MAP_HEIGHT);

for(let f of foods){
f.draw();
}

for(let bomb of bombs){
bomb.draw();
}

for(let s of snakes){
s.draw();
}

ctx.restore();

let scoreBoard = document.getElementById('scoreBoard');
let highScore = localStorage.getItem('highScore') || 0;
scoreBoard.innerHTML = "当前得分: " + playerSnake.normalFoodEaten +"&nbsp &nbsp &nbsp" +" 最高分: " + highScore;

requestAnimationFrame(gameLoop);
}

let gameOverFlag = false;
function gameOver() {
gameOverFlag = true;
alert("游戏结束！你的得分是：" + playerSnake.normalFoodEaten);
let highScore = localStorage.getItem('highScore') || 0;
if(playerSnake.normalFoodEaten > highScore){
localStorage.setItem('highScore', playerSnake.normalFoodEaten);
}
document.location.reload();
}

gameLoop();
</script>
</body>
</html>
